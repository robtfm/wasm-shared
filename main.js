// Import the wasm-bindgen generated JS glue code and Rust functions
import init, {
    initialize_shared_resources,
    read_shared_from_worker,
    set_realm
} from './pkg/wasm_shared.js'; // Adjust path if your pkg folder is elsewhere

const mainLog = document.getElementById('mainLog');
const workerLog = document.getElementById('workerLog');
const initButton = document.getElementById('initButton');
const workerButton = document.getElementById('workerButton');
const mainButton = document.getElementById('mainButton');

function logToMain(message) {
    console.log("[Main JS] " + message);
    mainLog.textContent += `[Main JS] ${message}\n`;
}

function logToWorkerDisplay(message) { // For messages received from worker
    console.log("[Worker JS via Main] " + message);
    workerLog.textContent += `${message}\n`;
}

async function run() {
    logToMain("Fetching Wasm module...");
    // Path to the _bg.wasm file generated by wasm-pack
    const wasmUrl = './pkg/wasm_shared_bg.wasm';
    let wasmBytes;
    try {
        const response = await fetch(wasmUrl);
        if (!response.ok) throw new Error(`Failed to fetch Wasm: ${response.statusText}`);
        wasmBytes = await response.arrayBuffer();
        logToMain("Wasm module fetched successfully.");
    } catch (error) {
        logToMain(`Error fetching Wasm: ${error}`);
        mainLog.textContent = `Error fetching Wasm: ${error}. Ensure the server is running and path is correct. Check network tab.`;
        return;
    }

    logToMain("Creating shared WebAssembly.Memory...");
    const memory = new WebAssembly.Memory({ initial: 256, maximum: 1024, shared: true });
    logToMain("Shared memory created.");

    try {
        logToMain("Initializing Wasm module (Instance A) on main thread...");
        await init({wasmBytes, memory});
        logToMain("Wasm module (Instance A) initialized on main thread.");
    } catch (error) {
        logToMain(`Error initializing Wasm (Instance A): ${error}`);
        mainLog.textContent = `Error initializing Wasm (Instance A): ${error}. Check console for details.`;
        return;
    }

    let worker;
    initButton.onclick = () => {
        try {
            logToMain("Calling Rust's initialize_shared_resources()...");
            initialize_shared_resources();
            workerButton.disabled = false;
            mainButton.disabled = false;
            initButton.disabled = true;

            if (!worker) {
                logToMain("Creating Web Worker...");
                worker = new Worker('worker.js', { type: 'module' });

                worker.onmessage = (e) => {
                    logToWorkerDisplay(`Message from worker: ${e.data}`);
                    if (e.data.startsWith("Error:")) {
                         workerLog.style.color = "red";
                    } else {
                         workerLog.style.color = "green";
                    }
                };
                worker.onerror = (e) => {
                    logToWorkerDisplay(`Error in worker: ${e.message} at ${e.filename}:${e.lineno}`);
                    workerLog.style.color = "red";
                };

                logToMain("Sending Wasm bytes and shared memory to worker...");
                // Send the *original* wasmBytes (ArrayBuffer) and the shared memory.
                // ArrayBuffer and WebAssembly.Memory are transferable.
                worker.postMessage({ type: 'INIT_WASM', wasmBytes, memory });
            }

        } catch (error) {
            logToMain(`Error during main thread Rust call: ${error}`);
            mainLog.textContent = `Error during main thread Rust call: ${error}. Check console for details.`;
        }
    };

    workerButton.onclick = () => {
        if (worker) {
            logToMain("Sending message to worker to read struct...");
            worker.postMessage({ type: 'READ_STRUCT' }); // 3.14 + 7.86 = 11.0
        } else {
            logToMain("Worker not initialized yet.");
        }
    };
    
    mainButton.onclick = () => {
        try {
            logToMain("Calling Rust's set_realm() from main thread...");
            set_realm("updated realm");
        } catch (error) {
            logToMain(`Error getting debug info: ${error}`);
        }
    };
}

run().catch(error => {
    console.error("[Main JS] Top level error:", error);
    mainLog.textContent = `Top level error: ${error}. Check console.`;
});
